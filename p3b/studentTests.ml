open OUnit2
open Types
open Eval
open Utils
open TestUtils

(* create_system_test is defined in testUtils.ml

   Signature:
        starting environment -> final environment -> filename -> test_ctxt -> unit
        You give the starting + ending environments + filename, generates test case (test_ctxt -> unit)

   Optional argument for expected output defaults to "", but can be set for output testing
*)

let test_no_output =
  create_system_test [] [("n", Int_Val(0)); ("b", Bool_Val(false))] "student_inputs/no_output.c"

let test_test_1 = create_system_test [] [("a", Int_Val 10);("sum", Int_Val 45); ("b", Int_Val 10)] "public_inputs/test1.c"
    ~output:"1\n10\n1\n3\n10\n3\n6\n10\n6\n10\n10\n10\n15\n10\n15\n21\n10\n21\n28\n10\n28\n36\n10\n36\n45\n20\n45\n"

let test_with_output =
  let e = [("prebound", Int_Val(123))] in
  (* The optional argument `output` is used to specify expected output.
     Optional arguments are specified as `~arg_name:arg_value`.
     This optional argument defaults to "" to represent no expected output. *)
  create_system_test e e "student_inputs/with_output.c" ~output:"123\n"

(* This variable defines the testing suite.
   Add your own tests to the list following the pattern for our two example tests. *)
let suite =
  "student" >::: [
    (* Tests are listed as name -> function to use
       The test named no_output is defined to use the test_no_output test function, generated by our testUtils file. Feel free to take a look if you're interested in the details / our other test methods that may be interesting to you. *)

    "no_output" >:: test_no_output;
    "with_output" >:: test_with_output;
    "test_1" >:: test_test_1;
  ]

(* Leave this alone - this kicks off the tests when the executable is run *)
let _ = run_test_tt_main suite
